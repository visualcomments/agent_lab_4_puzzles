{
  "planner": "You are solving CayleyPy RapaportM2 (moves I,S,K).\nDesign a constructive polynomial-time algorithm to sort an arbitrary permutation.\nYou MAY use the known trick: C = SK is an n-cycle with order evens increasing then odds decreasing; and conjugation P I P^{-1} swaps any adjacent pair in that cycle order.\nYour plan should explicitly define: (1) how to build the cycle order, (2) how to implement swap(cycle[j-1],cycle[j]) as a sequence of I,S,K moves, (3) an insertion-sort style procedure that places correct values at indices cycle[0], cycle[1], ... while never breaking already-fixed positions.\nNo BFS/DFS/A*. Provide a short correctness argument.",
  "coder": "Write a single self-contained solve_module.py implementing the planner's constructive approach for I,S,K only.\nContract: solve(vec)->(moves,sorted_array) and script mode prints JSON with keys moves,sorted_array.\nMoves must be list[str] subset {I,S,K}.\nImplement apply_I/apply_S/apply_K in-place (no slicing).\nImplement swap_adjacent_in_cycle(j) using P + [I] + reverse(P), where P represents C^{-j} and C=SK (so C^{-1}=KS).\nThen insertion-sort along the cycle order to achieve the globally sorted array.\nReturn only the full python file in one ```python``` block.",
  "fixer": "Fix the solver but keep the same constructive algorithm (cycle order + conjugation swaps). Ensure you never use built-in sorting or slicing for reordering. Ensure output JSON keys are exactly moves and sorted_array. Return full file only."
}

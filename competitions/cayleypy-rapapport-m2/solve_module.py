"""cayleypy-rapapport-m2 baseline solver

Kaggle competition: https://www.kaggle.com/competitions/cayleypy-rapapport-m2

This file implements a *constructive* sorting algorithm using only the
allowed generators (moves):

- I : swap positions 0 and 1
- S : swap (0,1), (2,3), (4,5), ...
- K : swap (1,2), (3,4), (5,6), ...

The goal is to transform an arbitrary permutation into the sorted state.

We use a simple (not optimal) O(n^3) algorithm:
- Consider the permutation C = S then K ("SK").
  C is an n-cycle on indices: [0,2,4,..., odds descending ... ,1].
- Using conjugation by powers of C, we can realize *adjacent transpositions*
  along that cycle order:

    swap(cycle[j-1], cycle[j]) == P * I * P^{-1}

  where P is C^{-j}.

- Adjacent transpositions along a line generate all permutations, so we can
  insertion-sort the array *in the cycle order* while targeting the globally
  sorted arrangement.

The produced move sequence is valid for the competition, but not score-optimal.

The module exposes:
    solve(vec) -> (moves, sorted_array)

and can be executed as a script:
    python solve_module.py "[3,0,1,4,2]"

It prints JSON: {"moves": [...], "sorted_array": [...]}
"""

from __future__ import annotations

import json
import sys
from typing import List, Sequence, Tuple

Move = str


def _apply_I(a: List[int]) -> None:
    if len(a) >= 2:
        a[0], a[1] = a[1], a[0]


def _apply_S(a: List[int]) -> None:
    n = len(a)
    i = 0
    while i + 1 < n:
        a[i], a[i + 1] = a[i + 1], a[i]
        i += 2


def _apply_K(a: List[int]) -> None:
    n = len(a)
    i = 1
    while i + 1 < n:
        a[i], a[i + 1] = a[i + 1], a[i]
        i += 2


def _apply_move(a: List[int], m: Move) -> None:
    if m == "I":
        _apply_I(a)
    elif m == "S":
        _apply_S(a)
    elif m == "K":
        _apply_K(a)
    else:
        raise ValueError(f"Unknown move: {m!r}")


def _cycle_order(n: int) -> List[int]:
    # Order of indices along the n-cycle generated by C = S then K.
    evens = list(range(0, n, 2))
    # largest odd < n
    last_odd = n - 1 if (n - 1) % 2 == 1 else n - 2
    odds_desc = list(range(last_odd, 0, -2))
    return evens + odds_desc


def _swap_adjacent_in_cycle(n: int, j: int) -> List[Move]:
    """Return a move sequence that swaps positions cycle[j-1] and cycle[j].

    Here cycle is the index order produced by _cycle_order(n).
    Valid for 1 <= j < n.

    Construction: P * I * P^{-1}, where P = C^{-j} and C = SK.

    We represent C^{-1} as the move pair "K","S".
    We choose the shorter representation between C^{-j}=(KS)^j and
    C^{n-j}=(SK)^{n-j} (they are equal since C^n = identity).
    """
    if j <= 0 or j >= n:
        raise ValueError("j must satisfy 1 <= j < n")

    forward = n - j  # C^{n-j}
    backward = j     # C^{-j}

    seq: List[Move] = []

    if backward <= forward:
        # P = (K,S)^j
        for _ in range(backward):
            seq.append("K")
            seq.append("S")
    else:
        # P = (S,K)^(n-j)
        for _ in range(forward):
            seq.append("S")
            seq.append("K")

    # Conjugation by P
    full = seq + ["I"] + list(reversed(seq))
    return full


def solve(vec: Sequence[int]) -> Tuple[List[Move], List[int]]:
    a = list(vec)
    n = len(a)

    if n <= 1:
        return [], a

    target = sorted(a)

    cycle = _cycle_order(n)
    inv_cycle = [0] * n
    for pos_in_cycle, idx in enumerate(cycle):
        inv_cycle[idx] = pos_in_cycle

    moves: List[Move] = []

    # Insertion-sort along the cycle order.
    for j in range(n):
        dest_idx = cycle[j]
        desired_val = target[dest_idx]

        # Find where the desired value currently is.
        cur_idx = 0
        while cur_idx < n and a[cur_idx] != desired_val:
            cur_idx += 1
        if cur_idx >= n:
            raise RuntimeError("desired value not found (input not a permutation?)")

        cur_pos = inv_cycle[cur_idx]

        while cur_pos > j:
            # swap edge between cycle[cur_pos-1] and cycle[cur_pos]
            seq = _swap_adjacent_in_cycle(n, cur_pos)
            for m in seq:
                _apply_move(a, m)
            moves.extend(seq)
            cur_pos -= 1

    return moves, a


def _main() -> None:
    if len(sys.argv) < 2:
        print("Usage: python solve_module.py '[3,0,1,4,2]'", file=sys.stderr)
        raise SystemExit(2)

    vec = json.loads(sys.argv[1])
    if not isinstance(vec, list):
        raise SystemExit("Input must be a JSON list")

    moves, sorted_array = solve(vec)
    print(json.dumps({"moves": moves, "sorted_array": sorted_array}))


if __name__ == "__main__":
    _main()
